package com.prirai.android.nira.browser.tabs.compose

import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Rect
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.launch

/**
 * Unified drag-and-drop system for all tab views.
 * Single implementation used by pill bar, list view, and grid view.
 */
class UnifiedDragSystem(
    private val scope: CoroutineScope,
    private val viewModel: TabViewModel
) {
    
    /**
     * Current drag state
     */
    data class DragState(
        val draggedNode: TabNode?,
        val fromContainerId: String?,
        val dragOffset: Offset = Offset.Zero,
        val isDragging: Boolean = false
    )
    
    var currentDragState by mutableStateOf(DragState(null, null))
        private set
    
    /**
     * Drop target zones (updated by composables)
     */
    private val dropTargets = mutableMapOf<String, Rect>()
    
    /**
     * Register a drop target
     */
    fun registerDropTarget(id: String, bounds: Rect) {
        dropTargets[id] = bounds
    }
    
    /**
     * Unregister a drop target
     */
    fun unregisterDropTarget(id: String) {
        dropTargets.remove(id)
    }
    
    /**
     * Start dragging a node
     */
    fun startDrag(node: TabNode, containerId: String?) {
        currentDragState = DragState(
            draggedNode = node,
            fromContainerId = containerId,
            isDragging = true
        )
    }
    
    /**
     * Update drag position
     */
    fun updateDragPosition(offset: Offset) {
        currentDragState = currentDragState.copy(dragOffset = offset)
    }
    
    /**
     * End drag and handle drop
     */
    fun endDrag(dropPosition: Offset) {
        val draggedNode = currentDragState.draggedNode
        if (draggedNode == null) {
            cancelDrag()
            return
        }
        
        // Find drop target
        val targetId = findDropTarget(dropPosition)
        
        if (targetId != null) {
            handleDrop(draggedNode, targetId)
        }
        
        cancelDrag()
    }
    
    /**
     * Cancel drag operation
     */
    fun cancelDrag() {
        currentDragState = DragState(null, null)
    }
    
    /**
     * Find drop target at position
     */
    private fun findDropTarget(position: Offset): String? {
        return dropTargets.entries.firstOrNull { (_, bounds) ->
            bounds.contains(position)
        }?.key
    }
    
    /**
     * Handle drop operation
     * Drop logic:
     * - Tab → Tab = create group
     * - Tab → Group = insert into group
     * - Tab out of group → move to root
     * - Group → reorder only (no nesting)
     */
    private fun handleDrop(draggedNode: TabNode, targetId: String) {
        scope.launch {
            when (draggedNode) {
                is Tab -> handleTabDrop(draggedNode, targetId)
                is TabGroup -> handleGroupDrop(draggedNode, targetId)
            }
        }
    }
    
    /**
     * Handle dropping a tab
     */
    private suspend fun handleTabDrop(tab: Tab, targetId: String) {
        when {
            targetId.startsWith("tab_") -> {
                // Tab → Tab: Create group
                val targetTabId = targetId.removePrefix("tab_")
                viewModel.createGroup(listOf(tab.id, targetTabId))
            }
            targetId.startsWith("group_") -> {
                // Tab → Group: Add to group
                val groupId = targetId.removePrefix("group_")
                viewModel.addTabToGroup(tab.id, groupId)
            }
            targetId == "root" -> {
                // Tab → Root: Remove from group if in one
                viewModel.removeTabFromGroup(tab.id)
            }
        }
    }
    
    /**
     * Handle dropping a group
     */
    private suspend fun handleGroupDrop(group: TabGroup, targetId: String) {
        // Groups can only be reordered, not nested
        if (targetId.startsWith("group_") || targetId == "root") {
            // Handle reorder in the order manager
            // This is done by the reorderable library
        }
    }
}

/**
 * Remember unified drag system
 */
@Composable
fun rememberUnifiedDragSystem(
    scope: CoroutineScope,
    viewModel: TabViewModel
): UnifiedDragSystem {
    return remember(scope, viewModel) {
        UnifiedDragSystem(scope, viewModel)
    }
}
