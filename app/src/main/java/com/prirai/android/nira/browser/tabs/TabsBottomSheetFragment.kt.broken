package com.prirai.android.nira.browser.tabs

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.prirai.android.nira.BrowserActivity
import com.prirai.android.nira.R
import com.prirai.android.nira.browser.BrowsingMode
import com.prirai.android.nira.browser.BrowsingModeManager
import com.prirai.android.nira.databinding.FragmentTabsBottomSheetBinding
import com.prirai.android.nira.ext.components
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import mozilla.components.lib.state.ext.flowScoped
import mozilla.components.browser.state.state.TabSessionState

class TabsBottomSheetFragment : BottomSheetDialogFragment() {

    private var _binding: FragmentTabsBottomSheetBinding? = null
    private val binding get() = _binding!!

    private lateinit var browsingModeManager: BrowsingModeManager
    private lateinit var tabsAdapter: TabsAdapter
    private var isInitializing = true

    companion object {
        const val TAG = "TabsBottomSheet"
        fun newInstance() = TabsBottomSheetFragment()
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentTabsBottomSheetBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        browsingModeManager = (activity as BrowserActivity).browsingModeManager

        setupUI()
        setupTabsAdapter()
        setupProfileChips()
        setupStoreObserver()
        
        isInitializing = false
    }

    override fun onStart() {
        super.onStart()

        val bottomSheetDialog = dialog as com.google.android.material.bottomsheet.BottomSheetDialog
        val behavior = bottomSheetDialog.behavior

        val screenHeight = resources.displayMetrics.heightPixels
        val desiredHeight = (screenHeight * 0.85).toInt()

        behavior.isFitToContents = false
        behavior.peekHeight = desiredHeight
        behavior.expandedOffset = screenHeight - desiredHeight
        behavior.state = com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_EXPANDED
        behavior.skipCollapsed = true
        behavior.isHideable = true
        behavior.isDraggable = true

        bottomSheetDialog.findViewById<View>(com.google.android.material.R.id.design_bottom_sheet)?.let { bottomSheet ->
            val layoutParams = bottomSheet.layoutParams
            layoutParams.height = desiredHeight
            bottomSheet.layoutParams = layoutParams
        }

        bottomSheetDialog.setCancelable(true)
        bottomSheetDialog.setCanceledOnTouchOutside(true)
    }

    private fun setupUI() {
        // FAB click listener
        binding.newTabFab.setOnClickListener {
            addNewTab()
        }
    }

    private fun setupTabsAdapter() {
        tabsAdapter = TabsAdapter(
            onTabClick = { tabId ->
                requireContext().components.tabsUseCases.selectTab(tabId)
                dismiss()
            },
            onTabClose = { tabId ->
                requireContext().components.tabsUseCases.removeTab(tabId)
            }
        )

        binding.tabsRecyclerView.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = tabsAdapter
        }
    }

    private fun setupProfileChips() {
        val profileManager = com.prirai.android.nira.browser.profile.ProfileManager.getInstance(requireContext())
        val profiles = profileManager.getAllProfiles()
        val isPrivateMode = browsingModeManager.mode.isPrivate
        val currentProfile = browsingModeManager.currentProfile

        binding.profileChipGroup.removeAllViews()
        binding.profileChipGroup.setOnCheckedStateChangeListener(null)

        var chipToCheck: com.google.android.material.chip.Chip? = null
        val profileIdMap = mutableMapOf<Int, String>()

        // Add profile chips
        profiles.forEach { profile ->
            val chip = LayoutInflater.from(requireContext())
                .inflate(R.layout.item_profile_chip, binding.profileChipGroup, false) as com.google.android.material.chip.Chip

            chip.text = "${profile.emoji} ${profile.name}"
            chip.tag = profile.id
            chip.id = View.generateViewId()
            profileIdMap[chip.id] = profile.id

            chip.setOnLongClickListener {
                if (!isInitializing) {
                    showProfileEditDialog(profile)
                }
                true
            }

            binding.profileChipGroup.addView(chip)

            if (!isPrivateMode && profile.id == currentProfile.id) {
                chipToCheck = chip
            }
        }

        // Add Private chip
        val privateChip = LayoutInflater.from(requireContext())
            .inflate(R.layout.item_profile_chip, binding.profileChipGroup, false) as com.google.android.material.chip.Chip
        privateChip.text = "ðŸ•µï¸ Private"
        privateChip.tag = "private"
        privateChip.id = View.generateViewId()
        profileIdMap[privateChip.id] = "private"
        binding.profileChipGroup.addView(privateChip)

        if (isPrivateMode) {
            chipToCheck = privateChip
        }

        // Add + chip
        val addChip = LayoutInflater.from(requireContext())
            .inflate(R.layout.item_profile_chip, binding.profileChipGroup, false) as com.google.android.material.chip.Chip
        addChip.text = "+"
        addChip.isCheckable = false
        addChip.id = View.generateViewId()
        addChip.setOnClickListener {
            showProfileCreateDialog()
        }
        binding.profileChipGroup.addView(addChip)

        chipToCheck?.let {
            binding.profileChipGroup.check(it.id)
        }

        // Set up listener
        binding.profileChipGroup.setOnCheckedStateChangeListener { _, checkedIds ->
            if (isInitializing || checkedIds.isEmpty()) return@setOnCheckedStateChangeListener

            val selectedChipId = checkedIds.first()
            val selectedProfileId = profileIdMap[selectedChipId]

            when (selectedProfileId) {
                "private" -> {
                    if (!browsingModeManager.mode.isPrivate) {
                        browsingModeManager.mode = BrowsingMode.Private
                        profileManager.setPrivateMode(true)
                        updateTabsDisplay()
                    }
                }
                else -> {
                    val profile = profiles.find { it.id == selectedProfileId }
                    if (profile != null && (browsingModeManager.mode.isPrivate || profile.id != browsingModeManager.currentProfile.id)) {
                        browsingModeManager.currentProfile = profile
                        browsingModeManager.mode = BrowsingMode.Normal
                        profileManager.setActiveProfile(profile)
                        profileManager.setPrivateMode(false)
                        updateTabsDisplay()
                    }
                }
            }
        }
    }

    private fun setupStoreObserver() {
        requireContext().components.store.flowScoped(viewLifecycleOwner) { flow ->
            flow.map { state -> state.tabs to state.selectedTabId }
                .distinctUntilChanged()
                .collect { (_, _) ->
                    updateTabsDisplay()
                }
        }
    }

    private fun updateTabsDisplay() {
        val store = requireContext().components.store.state
        val isPrivateMode = browsingModeManager.mode.isPrivate
        val currentProfile = browsingModeManager.currentProfile

        // Filter tabs by profile and mode
        val filteredTabs = store.tabs.filter { tab ->
            val tabIsPrivate = tab.content.private

            if (tabIsPrivate != isPrivateMode) {
                false
            } else if (isPrivateMode) {
                tab.contextId == "private"
            } else {
                val expectedContextId = "profile_${currentProfile.id}"
                tab.contextId == expectedContextId
            }
        }

        // Update adapter
        tabsAdapter.updateTabs(filteredTabs, store.selectedTabId)

        // Show/hide empty state
        if (filteredTabs.isEmpty()) {
            binding.tabsRecyclerView.visibility = View.GONE
            binding.emptyStateLayout.visibility = View.VISIBLE
        } else {
            binding.tabsRecyclerView.visibility = View.VISIBLE
            binding.emptyStateLayout.visibility = View.GONE
        }
    }

    private fun addNewTab() {
        val isPrivate = browsingModeManager.mode.isPrivate
        requireContext().components.tabsUseCases.addTab(
            url = "about:homepage",
            private = isPrivate
        )
    }

    private fun showProfileCreateDialog() {
        val composeView = androidx.compose.ui.platform.ComposeView(requireContext())
        composeView.setContent {
            androidx.compose.material3.MaterialTheme {
                com.prirai.android.nira.browser.profile.ProfileCreateDialog(
                    onDismiss = {
                        (composeView.parent as? ViewGroup)?.removeView(composeView)
                    },
                    onConfirm = { name, color, emoji ->
                        val profileManager = com.prirai.android.nira.browser.profile.ProfileManager.getInstance(requireContext())
                        val newProfile = profileManager.createProfile(name, color, emoji)

                        setupProfileChips()

                        browsingModeManager.currentProfile = newProfile
                        browsingModeManager.mode = BrowsingMode.Normal
                        updateTabsDisplay()

                        (composeView.parent as? ViewGroup)?.removeView(composeView)
                    }
                )
            }
        }

        (binding.root as ViewGroup).addView(composeView)
    }

    private fun showProfileEditDialog(profile: com.prirai.android.nira.browser.profile.BrowserProfile) {
        val composeView = androidx.compose.ui.platform.ComposeView(requireContext())
        composeView.setContent {
            androidx.compose.material3.MaterialTheme {
                com.prirai.android.nira.browser.profile.ProfileEditDialog(
                    profile = profile,
                    onDismiss = {
                        (composeView.parent as? ViewGroup)?.removeView(composeView)
                    },
                    onConfirm = { name, color, emoji ->
                        val profileManager = com.prirai.android.nira.browser.profile.ProfileManager.getInstance(requireContext())
                        val updatedProfile = profile.copy(name = name, color = color, emoji = emoji)
                        profileManager.updateProfile(updatedProfile)

                        if (profile.id == browsingModeManager.currentProfile.id) {
                            browsingModeManager.currentProfile = updatedProfile
                        }

                        setupProfileChips()

                        (composeView.parent as? ViewGroup)?.removeView(composeView)
                    },
                    onDelete = {
                        val profileManager = com.prirai.android.nira.browser.profile.ProfileManager.getInstance(requireContext())

                        if (profile.id == browsingModeManager.currentProfile.id) {
                            browsingModeManager.currentProfile = com.prirai.android.nira.browser.profile.BrowserProfile.getDefaultProfile()
                        }

                        profileManager.deleteProfile(profile.id)

                        setupProfileChips()
                        updateTabsDisplay()

                        (composeView.parent as? ViewGroup)?.removeView(composeView)
                    }
                )
            }
        }

        (binding.root as ViewGroup).addView(composeView)
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
